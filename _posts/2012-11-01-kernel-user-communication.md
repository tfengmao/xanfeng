---
title: 用户态-内核态通信方式
layout: post
category: linux
tags: kernel userland netlink procfs
---

值此小光棍节，夜深，我写此文。  
往事不敢追忆，而今奋起，期把握明日机会，追明日幸福。  
且愿我中意的女孩、中意我的女孩们此生幸福。  

###总纲——内核态与用户态通信的实现与分析（[链接](http://www.ibm.com/developerworks/cn/linux/l-netlink/index.html)）

多数的Linux内核态程序都需要和用户空间的进程交换数据，但是内核态无法对传统的Linux进程间同步和通信的方法提供足够的支持。下面总结并比较几种内核态与用户态进程通信的实现方法，并推荐使用netlink套接字实现**中断环境与用户态进程通信**。  

在一台运行Linux的计算机中，CPU在任何时候只会有如下四种状态：  
【1】在处理一个硬中断。  
【2】在处理一个软中断，如softirq、tasklet和bh。  
【3】运行于内核态，但有进程上下文，即与一个进程相关。  
【4】运行一个用户态进程。  
其中，【1】、【2】和【3】是运行于内核空间的，而【4】是在用户空间。其中除了【4】，其他状态只可以被在其之上的状态抢占。比如，软中断只可以被硬中断抢占。  

Linux内核模块是一段可以动态在内核装载和卸载的代码，装载进内核的代码便立即在内核中工作起来。  
Linux**内核代码的运行环境**有三种：用户上下文环境、硬中断环境和软中断环境。但三种环境的局限性分两种，因为软中断环境只是硬中断环境的延续。  
1、内核态环境——用户上下文：  
介绍：内核态代码的运行与一用户空间进程相关，如系统调用中代码的运行环境。  
局限：不可直接将本地变量传递给用户态的内存区，因为内核态和用户态的内存映射机制不同。  
2、内核态环境——硬中断和软中断环境：  
介绍：硬中断或软中断过程中代码的运行环境，如IP数据报的接收代码的运行环境，网络设备的驱动程序等。  
局限：不可直接向用户态内存区传递数据；代码在运行过程中不可阻塞。  

Linux传统的进程间通信有很多，如各类管道、消息队列、内存共享、信号量等等。但它们都无法介于内核态与用户态使用，原因：  
管道（不包括命名管道）：局限于父子进程间的通信。  
消息队列：在硬、软中断中无法无阻塞地接收数据。  
信号量：无法介于内核态和用户态使用。  
内存共享：需要信号量辅助，而信号量又无法使用。  
套接字：在硬、软中断中无法无阻塞地接收数据。  

**内核态环境——用户上下文：**  
运行在用户上下文环境中的代码是可以阻塞的，这样，便**可以使用消息队列和UNIX域套接字***（how？）*来实现内核态与用户态的通信。但这些方法的数据传输效率较低，Linux内核提供copy_from_user()/copy_to_user()函数来实现内核态与用户态数据的拷贝，但这两个函数会引发阻塞，所以不能用在硬、软中断中。  
一般将这两个特殊拷贝函数用在类似于系统调用一类的函数中，此类函数在使用中往往"穿梭"于内核态与用户态：  
![](http://www.ibm.com/developerworks/cn/linux/l-netlink/images/image001.gif)  

**内核态环境——硬中断和软中断环境：**  
【1】一般进程间通信的方法  
比起用户上下文环境，硬中断和软中断环境与用户态进程无丝毫关系，而且运行过程不能阻塞。我们无法直接使用传统的进程间通信的方法实现这样的内核代码和用户态通信。  
但硬、软中断中也有一套同步机制——自旋锁（spinlock），可以通过自旋锁来实现中断环境与中断环境、中断环境与内核线程的同步，而内核线程是运行在有进程上下文环境中的，这样便可以在内核线程中使用套接字或消息队列来取得用户空间的数据，然后再将数据通过临界区传递给中断过程*（强烈怀疑这个过程）*。如图所示：  
![](http://www.ibm.com/developerworks/cn/linux/l-netlink/images/image002.gif)  

因为中断过程不可能无休止地等待用户态进程发送数据，所以要通过一个内核线程来接收用户空间的数据，再通过临界区传给中断过程。中断过程向用户空间的数据发送必须是无阻塞的。这样的通信模型并不令人满意，因为内核线程是和其他用户态进程竞争CPU接收数据的，效率很低，这样中断过程便**不能实时地接收**来自用户空间的数据。  

【2】netlink socket  
在Linux 2.4版以后版本的内核中，几乎全部的中断过程与用户态进程的通信都是使用netlink socket实现的。netlink的最大特点是**支持中断过程**。  
netlink的通信依据是一个对应于进程的标识，一般定为该进程的ID。当通信的一端处于中断过程时，该标识为0。当使用netlink进行通信，通信的双方都是用户态进程时，使用方法类似于消息队列。但如果通信双方有一端是中断过程，使用方法则不同。它在内核空间接收用户空间数据时不再需要用户自行启动一个内核线程，而是通过另一个软中断调用用户事先指定的接收函数。如图所示：  
![](http://www.ibm.com/developerworks/cn/linux/l-netlink/images/image003.gif)  

这里使用了软中断而不是内核线程来接收数据，这样就可以保证**数据接收的实时性**。
